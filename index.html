<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neo Minigame V40</title>
    
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iYmFja2dyb3VuZDojMTIxMjEyIj48cGF0aCBmaWxsPSIjMjIyIiBkPSJNNjQgMTI4aDM4NGMzNS4zIDAgNjQgMjguNyA2NCA2NHYxMjhjMCAzNS4zLTI4LjcgNjQtNjQgNjRINjRjLTM1LjMgMC02NC0yOC43LTY0LTY0VjE5MmMwLTM1LjMgMjguNy02NCA2NC02NHoiLz48Y2lyY2xlIGN4PSIzODAiIGN5PSIyNTYiIHI9IjQwIiBmaWxsPSIjZmYwMDU1Ii8+PGNpcmNsZSBjeD0iMzAwIiBjeT0iMjkwIiByPSI0MCIgZmlsbD0iIzAwZmZjYyIvPjxwYXRoIGZpbGw9IiM0NDQiIGQ9Ik0xMjAgMjAwaDQwdjExMmgtNDB6Ii8+PHBhdGggZmlsbD0iIzQ0NCIgZD0iTTg0IDIzNmgxMTJ2NDBIODR6Ii8+PC9zdmc+">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iYmFja2dyb3VuZDojMTIxMjEyIj48cGF0aCBmaWxsPSIjMjIyIiBkPSJNNjQgMTI4aDM4NGMzNS4zIDAgNjQgMjguNyA2NCA2NHYxMjhjMCAzNS4zLTI4LjcgNjQtNjQgNjRINjRjLTM1LjMgMC02NC0yOC43LTY0LTY0VjE5MmMwLTM1LjMgMjguNy02NCA2NC02NHoiLz48Y2lyY2xlIGN4PSIzODAiIGN5PSIyNTYiIHI9IjQwIiBmaWxsPSIjZmYwMDU1Ii8+PGNpcmNsZSBjeD0iMzAwIiBjeT0iMjkwIiByPSI0MCIgZmlsbD0iIzAwZmZjYyIvPjxwYXRoIGZpbGw9IiM0NDQiIGQ9Ik0xMjAgMjAwaDQwdjExMmgtNDB6Ii8+PHBhdGggZmlsbD0iIzQ0NCIgZD0iTTg0IDIzNmgxMTJ2NDBIODR6Ii8+PC9zdmc+">
    <link rel="manifest" href='data:application/manifest+json,{"name":"Neo Minigame","short_name":"NeoGame","start_url":".","display":"standalone","background_color":"#121212","theme_color":"#121212","orientation":"portrait","icons":[{"src":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iYmFja2dyb3VuZDojMTIxMjEyIj48cGF0aCBmaWxsPSIjMjIyIiBkPSJNNjQgMTI4aDM4NGMzNS4zIDAgNjQgMjguNyA2NCA2NHYxMjhjMCAzNS4zLTI4LjcgNjQtNjQgNjRINjRjLTM1LjMgMC02NC0yOC43LTY0LTY0VjE5MmMwLTM1LjMgMjguNy02NCA2NC02NHoiLz48Y2lyY2xlIGN4PSIzODAiIGN5PSIyNTYiIHI9IjQwIiBmaWxsPSIjZmYwMDU1Ii8+PGNpcmNsZSBjeD0iMzAwIiBjeT0iMjkwIiByPSI0MCIgZmlsbD0iIzAwZmZjYyIvPjxwYXRoIGZpbGw9IiM0NDQiIGQ9Ik0xMjAgMjAwaDQwdjExMmgtNDB6Ii8+PHBhdGggZmlsbD0iIzQ0NCIgZD0iTTg0IDIzNmgxMTJ2NDBIODR6Ii8+PC9zdmc+","sizes":"512x512","type":"image/svg+xml","purpose":"any maskable"}]}'>

    <style>
        :root {
            --bg-body: #121212;
            --screen-bg: #1a1a2e;
            --neon-blue: #00f3ff;
            --neon-yellow: #ffcc00;
            --neon-red: #ff0055;
        }
        * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background-color: var(--bg-body); color: white; font-family: 'Courier New', Courier, monospace; height: 100dvh; margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        
        #console { 
            width: 100%; max-width: 450px; height: 100%; 
            background: linear-gradient(180deg, #2a2a2a 0%, #000 100%); 
            display: flex; flex-direction: column; 
            padding: 5px; 
            border-left: 3px solid #333; border-right: 3px solid #333; outline: none; 
        }
        
        #screen-area { 
            flex: 1; 
            background-color: var(--screen-bg); 
            border: 4px solid #000; border-radius: 8px; 
            margin-bottom: 20px; 
            position: relative; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; overflow: hidden; 
            box-shadow: inset 0 0 20px #000;
        }
        
        #ui-panel { width: 100%; position: absolute; top: 8px; padding: 0 12px; display: flex; justify-content: space-between; font-size: 16px; font-weight: bold; color: var(--neon-blue); text-shadow: 0 0 5px rgba(0, 243, 255, 0.5); z-index: 10; pointer-events: none;}
        #game-title { position: absolute; bottom: 8px; right: 12px; font-size: 14px; opacity: 0.4; pointer-events: none; font-weight: 900; white-space: nowrap; color: #fff; text-align: right; letter-spacing: 1px;}
        #level-indicator { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; color: #FFFF00; font-weight: bold; text-shadow: 3px 3px #FF0000; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 20; }
        
        canvas { background-color: transparent; image-rendering: pixelated; height: 98%; width: auto; max-width: 98%; aspect-ratio: 10/20; box-shadow: 0 0 15px rgba(0,0,0,0.8); }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; font-size: 24px; font-weight: bold; z-index: 50; text-align: center; cursor: pointer; }
        #start-screen { display: flex; }
        #gameover-screen { display: none; }
        .blink { animation: blinker 1s linear infinite; color: #ffcc00; margin-top: 15px; font-size: 16px;}
        @keyframes blinker { 50% { opacity: 0; } }

        #controls-area { 
            display: flex; flex-direction: column; justify-content: flex-end; 
            padding-bottom: 20px; flex-shrink: 0; min-height: 35vh;
        }

        .small-controls { display: flex; gap: 12px; justify-content: center; margin-bottom: 15px; }
        .small-btn { 
            width: 48px; height: 48px; 
            background: linear-gradient(145deg, #444, #222); border: 1px solid #555; border-radius: 12px; 
            color: #ddd; font-size: 16px; font-weight: 900; 
            box-shadow: 0 4px 0 #111, inset 0 1px 0 rgba(255,255,255,0.1); 
            display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.05s;
        }
        #btn-sound { font-size: 26px; }
        .small-btn:active, .btn-pressed { transform: translateY(3px); box-shadow: 0 1px 0 #111; color: var(--neon-blue); border-color: var(--neon-blue); }
        .btn-install { display: none; background: linear-gradient(145deg, #552255, #330033); color: #f0f; }

        #dynamic-controls {
            display: grid; width: 100%; height: 220px;
            grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;
            gap: 5px; align-items: center; justify-items: center; padding: 0 10px;
        }

        .neo-btn {
            cursor: pointer; position: relative;
            transition: transform 0.05s, filter 0.05s;
            display: flex; justify-content: center; align-items: center;
        }
        .neo-btn:active, .neo-active, .neo-action-active { transform: scale(0.92); filter: brightness(1.3); }
        
        /* Botões SVG (Triângulos e Círculo) */
        .btn-true-arrow {
            width: 80px; height: 80px;
            background-color: transparent;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 10 L90 85 L10 85 Z' fill='url(%23g)' stroke='%23ffee00' stroke-width='6' stroke-linejoin='round'/%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ffcc00'/%3E%3Cstop offset='100%25' stop-color='%23aa8800'/%3E%3C/linearGradient%3E%3C/defs%3E%3C/svg%3E");
            background-size: contain; background-repeat: no-repeat; background-position: center;
            filter: drop-shadow(0 4px 2px rgba(0,0,0,0.5));
        }
        .btn-true-arrow.neo-active { filter: drop-shadow(0 1px 1px rgba(0,0,0,0.5)) brightness(1.2); transform: translateY(2px); }

        .btn-true-arrow.up { transform: rotate(0deg); }
        .btn-true-arrow.down { transform: rotate(180deg); }
        .btn-true-arrow.left { transform: rotate(-90deg); }
        .btn-true-arrow.right { transform: rotate(90deg); }
        
        .btn-circle {
            width: 75px; height: 75px; border-radius: 50%;
            background: radial-gradient(circleAt 30% 30%, #ff4477, #990033);
            box-shadow: 0 6px 0 #550011, 0 0 10px rgba(0,0,0,0.5);
            border: 2px solid #ff88aa;
        }
        .btn-circle:active, .neo-action-active {
            transform: translateY(4px) scale(0.92); box-shadow: 0 2px 0 #550011;
            background: radial-gradient(circleAt 50% 50%, #ff0055, #770022);
        }

        /* Layouts */
        .layout-tetris { grid-template-areas: ". up ." "left action right" ". down ."; }
        .layout-tetris .b-up { grid-area: up; } .layout-tetris .b-down { grid-area: down; }
        .layout-tetris .b-left { grid-area: left; } .layout-tetris .b-right { grid-area: right; }
        .layout-tetris .b-action { grid-area: action; display: block; }

        .layout-cross { grid-template-areas: ". up ." "left . right" ". down ."; }
        .layout-cross .b-up { grid-area: up; display: block; } 
        .layout-cross .b-down { grid-area: down; display: block; }
        .layout-cross .b-left { grid-area: left; display: block; } 
        .layout-cross .b-right { grid-area: right; display: block; }
        .layout-cross .b-action { display: none; }

        .layout-shooter { grid-template-areas: ". up action" "left . right" ". down ."; }
        .layout-shooter .b-up { grid-area: up; display: block; } 
        .layout-shooter .b-down { grid-area: down; display: block; }
        .layout-shooter .b-left { grid-area: left; display: block; } 
        .layout-shooter .b-right { grid-area: right; display: block; }
        .layout-shooter .b-action { grid-area: action; display: block; justify-self: start; margin-left: 10px;}

        .layout-frogger { grid-template-areas: ". up ." "left . right" ". down ."; }
        .layout-frogger .b-up { grid-area: up; display: block; width: 80px; height: 80px;} 
        .layout-frogger .b-down { grid-area: down; display: block; width: 80px; height: 80px;}
        .layout-frogger .b-left { grid-area: left; display: block; width: 80px; height: 80px;}
        .layout-frogger .b-right { grid-area: right; display: block; width: 80px; height: 80px;}
        .layout-frogger .b-action { display: none; }

        .layout-horizontal { grid-template-areas: ". . ." "left . right" ". . ."; }
        .layout-horizontal .b-left { grid-area: left; width: 100px; height: 100px; }
        .layout-horizontal .b-right { grid-area: right; width: 100px; height: 100px; }
        .layout-horizontal .b-up, .layout-horizontal .b-down, .layout-horizontal .b-action { display: none; }

    </style>
</head>
<body>

<div id="console">
    <div id="screen-area">
        <div id="game-title">TETRIS</div>
        <div id="ui-panel">
            <span>SCORE <span id="score">0000</span></span>
            <span>HI <span id="highscore">0000</span></span>
        </div>
        <div id="level-indicator">LEVEL UP!</div>
        <canvas id="gameCanvas" width="200" height="400"></canvas>
        <div id="start-screen" class="overlay" onclick="startSystem()">
            <div style="font-size: 40px; margin-bottom: 20px;">▶</div>
            <div>TAP TO START</div>
        </div>
        <div id="gameover-screen" class="overlay" onclick="resetGame()">
            <div>GAME OVER</div>
            <div class="blink">RESET</div>
        </div>
    </div>

    <div id="controls-area">
        <div class="small-controls">
            <div class="small-btn btn-install" id="btn-install" onclick="installApp()">⬇</div>
            <div class="small-btn" id="btn-sound" onclick="toggleSound()">♪</div>
            <div class="small-btn btn-mode" onclick="switchGame()">MODE</div>
            <div class="small-btn" onclick="resetGame()">R</div>
            <div class="small-btn" id="btn-pause" onclick="togglePause()">P</div>
        </div>

        <div id="dynamic-controls" class="layout-tetris">
            <div class="neo-btn btn-true-arrow up b-up" data-key="up"></div>
            <div class="neo-btn btn-true-arrow left b-left" data-key="left"></div>
            <div class="neo-btn btn-circle b-action" data-key="action"></div>
            <div class="neo-btn btn-true-arrow right b-right" data-key="right"></div>
            <div class="neo-btn btn-true-arrow down b-down" data-key="down"></div>
        </div>
    </div>
</div>

<script>
    /* --- INPUT ENGINE CORRIGIDO (TIME SYNC) --- */
    const inputState = { up: false, down: false, left: false, right: false, action: false };
    const inputTimers = { up: 0, down: 0, left: 0, right: 0, action: 0 };
    
    function setupInputs() {
        const buttons = document.querySelectorAll('.neo-btn');
        buttons.forEach(btn => {
            const key = btn.getAttribute('data-key');
            
            const startHandler = (e) => {
                if(e.cancelable) e.preventDefault();
                if(inputState[key]) return; 
                inputState[key] = true;
                
                if(key==='action') btn.classList.add('neo-action-active');
                else btn.classList.add('neo-active');
                
                // CLICK (1x)
                executeInputLogic(key, true); 
                
                // PREPARA TURBO (200ms delay) - USANDO Date.now() PARA CONSISTENCIA
                inputTimers[key] = Date.now() + 200; 
            };
            const endHandler = (e) => {
                if(e.cancelable) e.preventDefault();
                inputState[key] = false;
                if(key==='action') btn.classList.remove('neo-action-active');
                else btn.classList.remove('neo-active');
                if(key === 'down' && gameMode === 'tetris') isFastDropping = false;
            };
            btn.addEventListener('mousedown', startHandler);
            btn.addEventListener('touchstart', startHandler, {passive: false});
            btn.addEventListener('mouseup', endHandler);
            btn.addEventListener('mouseleave', endHandler);
            btn.addEventListener('touchend', endHandler);
        });
    }

    // PROCESSADOR DE TURBO (Roda todo frame)
    function processInputs() {
        const now = Date.now(); // Usa relógio real para coincidir com setupInputs
        ['up', 'down', 'left', 'right', 'action'].forEach(key => {
            if (inputState[key]) {
                if (now > inputTimers[key]) {
                    // Executa Turbo
                    executeInputLogic(key, false);
                    // Define velocidade do turbo
                    let delay = 70;
                    if(gameMode === 'grandprix') delay = 150; 
                    if(gameMode === 'tetris' && (key === 'left' || key === 'right')) delay = 90; // Tetris lateral suave
                    inputTimers[key] = now + delay;
                }
            }
        });
    }

    function executeInputLogic(key, isFirstClick) {
        if (!isSystemStarted || isPaused || isGameOver || isCrashing) return;

        // TETRIS (Repetição Lateral e Drop)
        if (gameMode === 'tetris') {
            if (key === 'action' || key === 'up') {
                if (isFirstClick) { 
                    rotate(player.matrix, 1); 
                    if(collide(grid,player)) rotate(player.matrix, -1); 
                    else playSound('move'); 
                }
                return;
            }
            if (key === 'down') { isFastDropping = true; return; }
            if (key === 'left' || key === 'right') inputTetris(key);
            return;
        }

        // SNAKE / PACMAN / FROGGER
        if (gameMode === 'snake' || gameMode === 'pacman' || gameMode === 'frogger') {
            if(isFirstClick) {
                if(gameMode === 'snake') inputSnake(key);
                if(gameMode === 'pacman') inputPacman(key);
                if(gameMode === 'frogger') inputFrogger(key);
            }
            return; 
        }

        // OUTROS
        if (gameMode === 'race') inputRace(key);
        else if (gameMode === 'breakout') inputBreakout(key);
        else if (gameMode === 'grandprix') inputGrandPrix(key);
        else if (gameMode === 'shooter') inputShooter(key);
    }

    /* --- CONFIG & AUX --- */
    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score'); const hiScoreEl = document.getElementById('highscore');
    const titleEl = document.getElementById('game-title'); const levelIndEl = document.getElementById('level-indicator');
    const startScreen = document.getElementById('start-screen'); const gameoverScreen = document.getElementById('gameover-screen');
    const controlsContainer = document.getElementById('dynamic-controls');

    const COLS = 20; const ROWS = 40; const BLOCK_SIZE = 10; 
    const COLORS = ['#24243e', '#FF0055', '#00FFCC', '#FFFF00', '#FF6600', '#0099FF', '#9900FF', '#FF3333', '#00FF00', '#FF0000', '#FFFFFF', '#FF3300', '#00FFFF', '#FF00FF', '#FFFF00', '#FF0000', '#555577', '#333355', '#00FF00', '#FFFFFF', '#3333aa', '#dddddd', '#228822', '#00bbff', '#ffaa00', '#ff00ff', '#aaaaaa', '#87CEEB', '#F4A460', '#FFFF00', '#00FF00'];

    let gameMode = 'tetris'; let score = 0; let highScore = 0; 
    let isSystemStarted = false; let isGameOver = false; let isCrashing = false; let isPaused = false; 
    let soundEnabled = true; let lastTime = 0; let dropInterval = 800; let dropCounter = 0; let isFastDropping = false; let crashTimeout = null;

    let grid = []; let player = { pos: {x: 0, y: 0}, matrix: [], color: 1 };
    let snake = [], snakeDir = {x:0, y:0}, nextDir = {x:0, y:0}, food = {x:0, y:0};
    let racePlayerX = 8, raceEnemies = [], raceTick = 0;
    let ball = {x:0, y:0, dx:0, dy:0}, paddleX = 8;
    let pacman = {x:1, y:1}, pacDir = {x:0, y:0}, pacNextDir = {x:0, y:0}, ghosts = [], dots = [];
    let frog = {x:10, y:39}, lanes = [];
    let gp = { playerLane: 1, enemies: [], items: [], scenery: [], roadOffset: 0, baseSpeed: 90, scoreDist: 0, sceneryTimer: 0, level: 1 };
    let shooter = { playerX: 100, playerY: 360, bullets: [], enemies: [], items: [], spawnTimer: 0, lastShot: 0, stars: [], level: 1 };

    function loadHighScore() { const key = 'neoBrickHi_' + gameMode; highScore = parseInt(localStorage.getItem(key)) || 0; hiScoreEl.innerText = highScore.toString().padStart(4, '0'); }
    function saveHighScore() { if (score > highScore) { highScore = score; localStorage.setItem('neoBrickHi_' + gameMode, highScore); hiScoreEl.innerText = highScore.toString().padStart(4, '0'); } }
    
    function updateControlsLayout() {
        controlsContainer.className = ''; 
        if (gameMode === 'tetris') controlsContainer.classList.add('layout-tetris');
        else if (gameMode === 'snake' || gameMode === 'pacman') controlsContainer.classList.add('layout-cross');
        else if (gameMode === 'shooter') controlsContainer.classList.add('layout-shooter');
        else if (gameMode === 'frogger') controlsContainer.classList.add('layout-frogger');
        else controlsContainer.classList.add('layout-horizontal'); 
    }

    /* --- AUDIO --- */
    let audioCtx = null;
    function startSystem() {
        try {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            playTone(440, 'square', 0.1);
            isSystemStarted = true; setupInputs(); startScreen.style.display = 'none'; resetGame();
        } catch(e) { console.log(e); isSystemStarted=true; setupInputs(); startScreen.style.display='none'; resetGame();}
    }
    function playSound(type) {
        if (!soundEnabled || !isSystemStarted || !audioCtx) return;
        try {
            if (type === 'move') playTone(200, 'square', 0.25);
            else if (type === 'drop') playTone(100, 'sawtooth', 0.35);
            else if (type === 'hit') { playTone(150, 'sawtooth', 0.35); playTone(100, 'square', 0.4); }
            else if (type === 'gameover') { playTone(300, 'sawtooth', 0.5); setTimeout(() => playTone(150, 'sawtooth', 0.6), 200); } 
            else if (type === 'clear' || type === 'brick') { playTone(600, 'square', 0.3); playTone(800, 'sine', 0.3); }
            else if (type === 'eat' || type === 'powerup') { playTone(1000, 'sine', 0.3); playTone(1500, 'square', 0.3); } 
            else if (type === 'shoot') playTone(700, 'square', 0.25);
            else if (type === 'levelup') { playTone(880, 'square', 0.4); setTimeout(()=>playTone(1100, 'square', 0.5), 100); }
        } catch(e){}
    }
    function playTone(freq, type, duration) {
        try {
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.35, audioCtx.currentTime); 
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        } catch(e) {}
    }

    // Keyboard PC
    document.addEventListener('keydown', (e) => {
        if (!isSystemStarted && (e.code === 'Space' || e.code === 'Enter')) { startSystem(); return; }
        let key = null;
        if (e.code === 'ArrowUp') key = 'up'; if (e.code === 'ArrowDown') key = 'down';
        if (e.code === 'ArrowLeft') key = 'left'; if (e.code === 'ArrowRight') key = 'right';
        if (e.code === 'Space') key = 'action';
        if (key && !inputState[key]) {
            inputState[key] = true;
            const btn = document.querySelector(`.neo-btn[data-key="${key}"]`);
            if(btn) { if(key==='action') btn.classList.add('neo-action-active'); else btn.classList.add('neo-active'); }
            executeInputLogic(key, true); 
            inputTimers[key] = Date.now() + 200;
        }
        if(key) e.preventDefault();
    });
    document.addEventListener('keyup', (e) => {
        let key = null;
        if (e.code === 'ArrowUp') key = 'up'; if (e.code === 'ArrowDown') key = 'down';
        if (e.code === 'ArrowLeft') key = 'left'; if (e.code === 'ArrowRight') key = 'right';
        if (e.code === 'Space') key = 'action';
        if (key) {
            inputState[key] = false;
            if(key === 'down' && gameMode === 'tetris') isFastDropping = false;
            const btn = document.querySelector(`.neo-btn[data-key="${key}"]`);
            if(btn) { if(key==='action') btn.classList.remove('neo-action-active'); else btn.classList.remove('neo-active'); }
        }
    });

    /* --- PWA --- */
    let deferredPrompt;
    if ('serviceWorker' in navigator) {
        const swContent = "self.addEventListener('fetch', function(event) { return; });";
        const blob = new Blob([swContent], {type: 'text/javascript'});
        const swUrl = URL.createObjectURL(blob);
        navigator.serviceWorker.register(swUrl).catch(console.error);
    }
    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault(); deferredPrompt = e;
        document.getElementById('btn-install').style.display = 'flex';
    });
    async function installApp() {
        if (deferredPrompt) { deferredPrompt.prompt(); const { outcome } = await deferredPrompt.userChoice; if (outcome === 'accepted') { deferredPrompt = null; document.getElementById('btn-install').style.display = 'none'; } } 
        else { alert("Para instalar: No Chrome, toque nos 3 pontinhos e selecione 'Adicionar à Tela Inicial'."); }
    }

    /* --- UTIL & GRAPHICS --- */
    let particles = [];
    class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8; this.alpha = 1; this.color = color || '#FFF'; this.size = Math.random() * 4 + 2; } update() { this.x += this.vx; this.y += this.vy; this.alpha -= 0.03; this.size *= 0.9; } draw(ctx) { ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1; } }
    function spawnExplosion(x, y, colorCode) { let color = (typeof colorCode === 'string') ? colorCode : COLORS[colorCode]; for(let i=0; i<12; i++) particles.push(new Particle(x, y, color)); }
    function updateParticles() { for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if (particles[i].alpha <= 0) particles.splice(i, 1); } }
    function drawParticles() { particles.forEach(p => p.draw(ctx)); }
    function createMatrix(w, h) { const matrix = []; while (h--) matrix.push(new Array(w).fill(0)); return matrix; }
    function drawPixel(x, y, colorCode) {
        if (colorCode === undefined || colorCode < 0 || colorCode >= COLORS.length) return;
        ctx.shadowBlur = (colorCode !== 0 && colorCode !== 17 && colorCode !== 16 && colorCode !== 19) ? 6 : 0;
        if(colorCode !== 0) ctx.shadowColor = COLORS[colorCode];
        if (gameMode === 'tetris' || gameMode === 'snake') {
            if(colorCode !== 0) { ctx.fillStyle = COLORS[colorCode]; ctx.fillRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2); } 
            else { ctx.strokeStyle = 'rgba(200, 200, 200, 0.15)'; ctx.lineWidth = 1; ctx.strokeRect(x * BLOCK_SIZE + 0.5, y * BLOCK_SIZE + 0.5, BLOCK_SIZE - 1, BLOCK_SIZE - 1); }
        } else {
            if(colorCode !== 0) { ctx.fillStyle = COLORS[colorCode]; ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); }
        }
        ctx.shadowBlur = 0;
    }
    function addScore(pts) { score += pts; scoreEl.innerText = score.toString().padStart(4, '0'); saveHighScore(); }
    function triggerCrash(x, y, color) { if(isCrashing || isGameOver) return; isCrashing = true; if (gameMode === 'grandprix' || gameMode === 'shooter') spawnExplosion(x, y, color); else spawnExplosion(x * BLOCK_SIZE + 5, y * BLOCK_SIZE + 5, COLORS[color]); playSound('hit'); crashTimeout = setTimeout(() => setGameOver(), 1500); }
    function setGameOver() { if(isGameOver) return; isGameOver = true; isCrashing = false; playSound('gameover'); gameoverScreen.style.display = 'flex'; }
    function showLevelUp() { levelIndEl.style.opacity = 1; playSound('levelup'); setTimeout(() => levelIndEl.style.opacity = 0, 1500); }

    /* --- JOGOS --- */
    function initTetris() { grid = createMatrix(COLS, ROWS); dropInterval = 800; spawnPiece(); }
    function inputTetris(a) { if(a=='left'){player.pos.x--;if(collide(grid,player))player.pos.x++;else playSound('move')} if(a=='right'){player.pos.x++;if(collide(grid,player))player.pos.x--;else playSound('move')} } 
    function updateTetris(dt) { dropCounter+=dt; if(dropCounter>(isFastDropping?30:dropInterval)){ player.pos.y++; if(collide(grid,player)){player.pos.y--;merge(grid,player);playSound('drop');sweep();spawnPiece();} dropCounter=0; } }
    function drawTetris() { for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)drawPixel(x,y,grid[y][x]); if(!isGameOver)player.matrix.forEach((r,y)=>{r.forEach((v,x)=>{if(v)drawPixel(x+player.pos.x,y+player.pos.y,player.color)})}); }
    function spawnPiece(){const p='ILJOTSZ';const t=p[Math.random()*p.length|0];player.matrix=createPiece(t);player.color=(Math.random()*7|0)+1;player.pos={x:8,y:0};if(collide(grid,player))setGameOver();}
    function createPiece(t){if(t=='I')return[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];if(t=='O')return[[4,4],[4,4]];if(t=='T')return[[0,7,0],[7,7,7],[0,0,0]];if(t=='L')return[[0,2,0],[0,2,0],[0,2,2]];if(t=='J')return[[0,3,0],[0,3,0],[3,3,0]];if(t=='Z')return[[5,5,0],[0,5,5],[0,0,0]];if(t=='S')return[[0,6,6],[6,6,0],[0,0,0]];return[[1]]}
    function collide(a,p){const[m,o]=[p.matrix,p.pos];for(let y=0;y<m.length;++y)for(let x=0;x<m[y].length;++x)if(m[y][x]!==0&&(a[y+o.y]&&a[y+o.y][x+o.x])!==0)return true;return false}
    function merge(a,p){p.matrix.forEach((r,y)=>r.forEach((v,x)=>{if(v&&(a[y+p.pos.y]&&a[y+p.pos.y][x+p.pos.x]!==undefined))a[y+p.pos.y][x+p.pos.x]=p.color}));}
    function sweep(){let c=1;for(let y=ROWS-1;y>=0;y--){if(grid[y].every(v=>v!==0)){for(let x=0; x<COLS; x++) spawnExplosion(x*BLOCK_SIZE, y*BLOCK_SIZE, COLORS[grid[y][x]]);grid.splice(y,1);grid.unshift(new Array(COLS).fill(0));y++;addScore(c*10);c*=2;playSound('clear')}}}
    function rotate(m,d){for(let y=0;y<m.length;++y)for(let x=0;x<y;++x)[m[x][y],m[y][x]]=[m[y][x],m[x][y]];if(d>0)m.forEach(r=>r.reverse());else m.reverse()}

    function initSnake(){snake=[{x:10,y:20},{x:10,y:21},{x:10,y:22}];snakeDir={x:0,y:-1};nextDir={x:0,y:-1};dropInterval=100;placeFood();}
    function inputSnake(a){if(a=='up'&&snakeDir.y==0)nextDir={x:0,y:-1};if(a=='down'&&snakeDir.y==0)nextDir={x:0,y:1};if(a=='left'&&snakeDir.x==0)nextDir={x:-1,y:0};if(a=='right'&&snakeDir.x==0)nextDir={x:1,y:0};}
    function updateSnake(dt){dropCounter+=dt;if(dropCounter>dropInterval){snakeDir=nextDir;const h={x:snake[0].x+snakeDir.x,y:snake[0].y+snakeDir.y};if(h.x<0||h.x>=COLS||h.y<0||h.y>=ROWS||snake.some(s=>s.x==h.x&&s.y==h.y)){triggerCrash(snake[0].x, snake[0].y, 8);return}snake.unshift(h);if(h.x==food.x&&h.y==food.y){playSound('eat');addScore(10);placeFood()}else{snake.pop()}dropCounter=0}}
    function drawSnake(){for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)drawPixel(x,y,0);drawPixel(food.x,food.y,9);snake.forEach(s=>drawPixel(s.x,s.y,8))}
    function placeFood(){let empty = []; for(let y=0; y<ROWS; y++) { for(let x=0; x<COLS; x++) { if(!snake.some(s => s.x === x && s.y === y)) empty.push({x,y}); } } if(empty.length > 0) { let rnd = Math.floor(Math.random() * empty.length); food = empty[rnd]; } else { setGameOver(); } }

    function initRace(){racePlayerX=8;raceEnemies=[];dropInterval=60;raceTick=0}
    function inputRace(a){if(a=='left'){if(racePlayerX>10){racePlayerX=8;playSound('move')}else if(racePlayerX>4){racePlayerX=2;playSound('move')}}if(a=='right'){if(racePlayerX<6){racePlayerX=8;playSound('move')}else if(racePlayerX<12){racePlayerX=14;playSound('move')}}}
    function updateRace(dt){
        if(inputState.left && racePlayerX > 2) racePlayerX -= 0.2; if(inputState.right && racePlayerX < 14) racePlayerX += 0.2;
        dropCounter+=dt;if(dropCounter>(isFastDropping?20:dropInterval)){raceTick++;if(raceTick%20==0){let lane=[2,8,14][Math.floor(Math.random()*3)];raceEnemies.push({x:lane,y:-3});}for(let i=0;i<raceEnemies.length;i++){raceEnemies[i].y++;if(raceEnemies[i].y>ROWS){raceEnemies.splice(i,1);i--;addScore(10);playSound('move')}}const pX=racePlayerX,pY=35;for(let e of raceEnemies){if(Math.abs(e.x-pX)<3&&Math.abs(e.y-pY)<4){triggerCrash(pX, pY, 10); triggerCrash(e.x, e.y, 11);}}dropCounter=0}}
    function drawRace(){for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)drawPixel(x,y,0);for(let y=0;y<ROWS;y++){if(y%2==0){drawPixel(5,y,0);drawPixel(11,y,0);}}raceEnemies.forEach(e=>drawCar(e.x,e.y,11));drawCar(Math.round(racePlayerX),35,10)}
    function drawCar(cx,cy,c){drawPixel(cx,cy,c);drawPixel(cx-1,cy+1,c);drawPixel(cx,cy+1,c);drawPixel(cx+1,cy+1,c);drawPixel(cx-1,cy+2,c);drawPixel(cx+1,cy+2,c)}

    function initBreakout(){grid=createMatrix(COLS,ROWS);for(let y=4;y<12;y++)for(let x=0;x<COLS;x++)grid[y][x]=13;paddleX=8;ball={x:10,y:30,dx:1,dy:-1};dropInterval=80}
    function inputBreakout(a){} 
    function updateBreakout(dt){
        if(inputState.left && paddleX > 0) paddleX -= 0.5; if(inputState.right && paddleX < COLS-5) paddleX += 0.5;
        dropCounter+=dt;if(dropCounter>dropInterval){let nx=ball.x+ball.dx,ny=ball.y+ball.dy;if(nx<0||nx>=COLS){ball.dx*=-1;nx=ball.x+ball.dx;playSound('hit')}if(ny<0){ball.dy*=-1;ny=ball.y+ball.dy;playSound('hit')}if(ny>=ROWS){triggerCrash(ball.x, ball.y, 12);return}if(ny==36&&nx>=Math.round(paddleX)&&nx<=Math.round(paddleX)+4){ball.dy*=-1;ny=ball.y+ball.dy;playSound('drop')}if(grid[ny]&&grid[ny][Math.floor(nx)]!==0){spawnExplosion(Math.floor(nx)*BLOCK_SIZE, ny*BLOCK_SIZE, COLORS[grid[ny][Math.floor(nx)]]);grid[ny][Math.floor(nx)]=0;ball.dy*=-1;addScore(10);playSound('brick')}ball.x=nx;ball.y=ny;dropCounter=0}}
    function drawBreakout(){for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)drawPixel(x,y,grid[y][x]);for(let i=0;i<5;i++)drawPixel(Math.round(paddleX)+i,36,12);drawPixel(ball.x,ball.y,12)}

    function initPacman() {grid = createMatrix(COLS, ROWS); dots = [];for(let y=0; y<ROWS; y++) {for(let x=0; x<COLS; x++) {if (x==0 || x==COLS-1 || y==0 || y==ROWS-1 || (y%4==0 && x%4!=0) || (x%6==0 && y%3!=0)) {grid[y][x] = 17;} else {grid[y][x] = 0; dots.push({x:x, y:y});}}}for(let y=30;y<35;y++)for(let x=8;x<12;x++){grid[y][x]=0; dots=dots.filter(d=>d.x!=x||d.y!=y)};pacman={x:10,y:32}; pacDir={x:0,y:0}; pacNextDir={x:0,y:0};ghosts=[{x:2,y:2},{x:17,y:2},{x:2,y:37},{x:17,y:37}];dropInterval=220;}
    function inputPacman(a) {if(a=='up') pacNextDir = {x:0, y:-1};if(a=='down') pacNextDir = {x:0, y:1};if(a=='left') pacNextDir = {x:-1, y:0};if(a=='right') pacNextDir = {x:1, y:0};}
    function updatePacman(dt) {dropCounter += dt;if (dropCounter > dropInterval) {let tx = pacman.x + pacNextDir.x, ty = pacman.y + pacNextDir.y;if (isValidPacMove(tx, ty)) pacDir = pacNextDir;let nx = pacman.x + pacDir.x, ny = pacman.y + pacDir.y;if (isValidPacMove(nx, ny)) { pacman.x = nx; pacman.y = ny; }let dIdx = dots.findIndex(d => d.x === pacman.x && d.y === pacman.y);if (dIdx !== -1) {dots.splice(dIdx, 1); addScore(10); playSound('eat');if(dots.length === 0) { playSound('clear'); initPacman(); return; }}ghosts.forEach(g => {let moves = [{x:0,y:1}, {x:0,y:-1}, {x:1,y:0}, {x:-1,y:0}];if (Math.random() > 0.4) {if (pacman.x > g.x) moves.unshift({x:1,y:0}); else moves.unshift({x:-1,y:0});if (pacman.y > g.y) moves.unshift({x:0,y:1}); else moves.unshift({x:0,y:-1});}for(let m of moves) {if(isValidPacMove(g.x+m.x, g.y+m.y)) { g.x+=m.x; g.y+=m.y; break; }}if (g.x === pacman.x && g.y === pacman.y) { triggerCrash(pacman.x, pacman.y, 14);} });dropCounter = 0;}}
    function isValidPacMove(x, y) { return x>=0 && x<COLS && y>=0 && y<ROWS && grid[y][x]!==17; }
    function drawPacman() {for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {if(grid[y][x] === 17) drawPixel(x,y,17); else drawPixel(x,y,0);}dots.forEach(d => drawPixel(d.x, d.y, 16)); drawPixel(pacman.x, pacman.y, 14); ghosts.forEach(g => drawPixel(g.x, g.y, 15));}

    function initFrogger() {frog = {x: 10, y: 39};dropInterval = 150; lanes = [];for(let i=38; i>5; i-=2) {let speed = Math.random() * 500 + 200;let dir = Math.random() > 0.5 ? 1 : -1;let density = Math.random() > 0.5 ? 0.2 : 0.4;let map = new Array(COLS).fill(0).map(()=>Math.random()<density?1:0);lanes.push({y:i, dir:dir, speed:speed, timer:0, map:map});}}
    function inputFrogger(a) {let moved = false;if(a=='up' && frog.y > 0) { frog.y--; moved=true; }if(a=='down' && frog.y < 39) { frog.y++; moved=true; }if(a=='left' && frog.x > 0) { frog.x--; moved=true; }if(a=='right' && frog.x < 19) { frog.x++; moved=true; }if(moved){ playSound('move'); checkFrogCollision(); }}
    function updateFrogger(dt) {lanes.forEach(lane => {lane.timer += dt;if (lane.timer > lane.speed) {lane.timer = 0;if (lane.dir === 1) lane.map.unshift(lane.map.pop());else lane.map.push(lane.map.shift());checkFrogCollision();}});if (frog.y <= 0) {playSound('clear'); addScore(100); frog.x = 10; frog.y = 39;}}
    function checkFrogCollision() {const lane = lanes.find(l => l.y === frog.y);if (lane && lane.map[frog.x] === 1) {triggerCrash(frog.x, frog.y, 18);}}
    function drawFrogger() {for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) drawPixel(x,y,0);lanes.forEach(lane => { lane.map.forEach((val, x) => { if (val === 1) drawPixel(x, lane.y, 19); }); });drawPixel(frog.x, frog.y, 18);}

    function initGrandPrix() { gp = { playerLane: 1, enemies: [], items: [], scenery: [], roadOffset: 0, baseSpeed: 90, scoreDist: 0, sceneryTimer: 0, level: 1 }; }
    function inputGrandPrix(a) { if(a === 'left' && gp.playerLane > 0) { gp.playerLane--; playSound('move'); } if(a === 'right' && gp.playerLane < 2) { gp.playerLane++; playSound('move'); } }
    function updateGrandPrix(dt) {
        gp.baseSpeed += dt * 0.005; let oldLevel = gp.level; gp.level = 1 + Math.floor(score / 500); if(gp.level > oldLevel) showLevelUp();
        let currentSpeed = isFastDropping ? gp.baseSpeed * 3 : gp.baseSpeed;
        gp.roadOffset += (currentSpeed * dt * 0.05); if(gp.roadOffset > 100) gp.roadOffset = 0; 
        gp.scoreDist += dt; if(gp.scoreDist > (60000 / currentSpeed)) { gp.scoreDist = 0; let l = Math.floor(Math.random() * 3); if(Math.random() < 0.2) gp.items.push({lane: l, y: 100, z: 0}); else gp.enemies.push({lane: l, y: 100, z: 0}); }
        gp.sceneryTimer += dt; if(gp.sceneryTimer > (20000 / currentSpeed)) { gp.sceneryTimer = 0; let side = Math.random() > 0.5 ? 1 : 0; gp.scenery.push({side: side, y: 100, z: 0}); }
        for(let i=0; i<gp.enemies.length; i++) { let e = gp.enemies[i]; e.z += dt * 0.0005 * (currentSpeed/100); e.y = 100 + (e.z * e.z * e.z) * 300; if(e.y > 400) { gp.enemies.splice(i, 1); i--; addScore(100); playSound('move'); } if(e.y > 330 && e.y < 390 && e.lane === gp.playerLane) { let exX = getLaneCenterX(e.lane, e.y); let pX = getLaneCenterX(gp.playerLane, 360); triggerCrash(exX, e.y, '#FFF'); triggerCrash(pX, 360, '#000'); } }
        for(let i=0; i<gp.items.length; i++) { let item = gp.items[i]; item.z += dt * 0.0005 * (currentSpeed/100); item.y = 100 + (item.z * item.z * item.z) * 300; if(item.y > 400) { gp.items.splice(i, 1); i--; } if(item.y > 330 && item.y < 390 && item.lane === gp.playerLane) { gp.items.splice(i, 1); i--; addScore(50); playSound('powerup'); } }
        for(let i=0; i<gp.scenery.length; i++) { let s = gp.scenery[i]; s.z += dt * 0.0005 * (currentSpeed/100); s.y = 100 + (s.z * s.z * s.z) * 300; if(s.y > 400) { gp.scenery.splice(i, 1); i--; } }
    }
    function drawGrandPrix() {
        ctx.fillStyle = COLORS[27]; ctx.fillRect(0, 0, 200, 100); ctx.fillStyle = "#FFF"; ctx.fillRect(20, 30, 40, 10); ctx.fillRect(140, 50, 30, 8); ctx.fillStyle = COLORS[28]; ctx.fillRect(0, 100, 200, 300); ctx.fillStyle = "#222"; ctx.beginPath(); ctx.moveTo(0, 100); ctx.lineTo(40, 60); ctx.lineTo(80, 100); ctx.lineTo(120, 50); ctx.lineTo(160, 90); ctx.lineTo(200, 60); ctx.lineTo(200, 100); ctx.fill(); ctx.fillStyle = "#777"; ctx.beginPath(); ctx.moveTo(80, 100); ctx.lineTo(120, 100); ctx.lineTo(200, 400); ctx.lineTo(0, 400); ctx.fill(); ctx.strokeStyle = "#FFF"; ctx.lineWidth = 2; ctx.beginPath(); ctx.setLineDash([10, 10]); ctx.lineDashOffset = -gp.roadOffset; ctx.moveTo(93, 100); ctx.lineTo(66, 400); ctx.moveTo(107, 100); ctx.lineTo(133, 400); ctx.stroke(); ctx.setLineDash([]); 
        gp.scenery.forEach(s => { let width = 4 + (s.y-100) * 0.5; let centerX = (s.side === 0) ? (100 - width/2 - 20) : (100 + width/2 + 20); let perspectiveX = (s.side === 0) ? centerX - (s.y-100)*0.3 : centerX + (s.y-100)*0.3; let scale = 0.2 + (s.y - 100) / 300; drawCactus(perspectiveX, s.y, scale); });
        gp.items.forEach(it => { let cx = getLaneCenterX(it.lane, it.y); let scale = 0.2 + (it.y - 100) / 300; let sz = 15 * scale; ctx.fillStyle = COLORS[29]; ctx.beginPath(); ctx.arc(cx, it.y, sz, 0, Math.PI*2); ctx.fill(); });
        gp.enemies.forEach(e => { let cx = getLaneCenterX(e.lane, e.y); let scale = 0.2 + (e.y - 100) / 300; drawF1Car(cx, e.y, scale, '#000'); });
        let px = getLaneCenterX(gp.playerLane, 360); drawF1Car(px, 360, 1.2, '#000'); 
    }
    function getLaneCenterX(laneIdx, y) { let progress = (y - 100) / 300; let roadWidthAtY = 40 + (160 * progress); let laneWidth = roadWidthAtY / 3; let leftEdge = 100 - (roadWidthAtY/2); return leftEdge + laneWidth * (laneIdx + 0.5); }
    function drawF1Car(x, y, scale, color) { ctx.fillStyle = color; let w = 20 * scale; let h = 30 * scale; ctx.fillRect(x - w*0.15, y - h/2, w*0.3, h); ctx.fillRect(x - w/2, y + h*0.2, w*0.3, h*0.3); ctx.fillRect(x + w*0.2, y + h*0.2, w*0.3, h*0.3); ctx.fillRect(x - w*0.4, y - h*0.4, w*0.2, h*0.2); ctx.fillRect(x + w*0.2, y - h*0.4, w*0.2, h*0.2); ctx.fillRect(x - w*0.4, y + h*0.4, w*0.8, h*0.1); ctx.beginPath(); ctx.moveTo(x, y - h/2); ctx.lineTo(x - w*0.1, y - h*0.6); ctx.lineTo(x + w*0.1, y - h*0.6); ctx.fill(); }
    function drawCactus(x, y, scale) { ctx.fillStyle = COLORS[22]; let h = 20 * scale; let w = 6 * scale; ctx.fillRect(x - w/2, y - h, w, h); ctx.fillRect(x - w*1.5, y - h*0.6, w, h*0.3); ctx.fillRect(x + w*0.5, y - h*0.8, w, h*0.3); ctx.fillRect(x - w*1.5, y - h*0.9, w, h*0.3); ctx.fillRect(x + w*0.5, y - h*1.1, w, h*0.3); }

    function initShooter() { shooter = { playerX: 100, playerY: 360, bullets: [], enemies: [], items: [], spawnTimer: 0, lastShot: 0, stars: [], level: 1 }; dropInterval = 1000; for(let i=0; i<50; i++) shooter.stars.push({x: Math.random()*200, y: Math.random()*400, speed: Math.random()*2+1}); }
    function inputShooter(a) { const speed = 8; if (a === 'left' && shooter.playerX > 10) shooter.playerX -= speed; if (a === 'right' && shooter.playerX < 190) shooter.playerX += speed; if (a === 'action' || a === 'up') { const now = Date.now(); let cooldown = (shooter.level >= 2) ? 150 : 250; if (now - shooter.lastShot > cooldown) { if(shooter.level <= 2) { shooter.bullets.push({x: shooter.playerX, y: shooter.playerY - 15, vx: 0, vy: -5}); } else if (shooter.level === 3) { shooter.bullets.push({x: shooter.playerX - 8, y: shooter.playerY - 15, vx: 0, vy: -5}); shooter.bullets.push({x: shooter.playerX + 8, y: shooter.playerY - 15, vx: 0, vy: -5}); } else { shooter.bullets.push({x: shooter.playerX, y: shooter.playerY - 15, vx: 0, vy: -5}); shooter.bullets.push({x: shooter.playerX-5, y: shooter.playerY - 15, vx: -1, vy: -5}); shooter.bullets.push({x: shooter.playerX+5, y: shooter.playerY - 15, vx: 1, vy: -5}); } playSound('shoot'); shooter.lastShot = now; } } }
    function updateShooter(dt) { dropInterval -= dt * 0.01; let oldLevel = shooter.level; if (score < 500) shooter.level = 1; else if (score < 1500) shooter.level = 2; else if (score < 3000) shooter.level = 3; else shooter.level = 4; if(shooter.level > oldLevel) showLevelUp(); shooter.stars.forEach(s => { s.y += s.speed; if(s.y > 400) s.y = 0; }); for (let i = shooter.bullets.length - 1; i >= 0; i--) { let b = shooter.bullets[i]; b.y += b.vy; b.x += b.vx; if (b.y < 0 || b.x < 0 || b.x > 200) shooter.bullets.splice(i, 1); } shooter.spawnTimer += dt; if (shooter.spawnTimer > dropInterval) { shooter.spawnTimer = 0; if(Math.random() < 0.1) { shooter.items.push({x: Math.random() * 180 + 10, y: -20}); } else { shooter.enemies.push({x: Math.random() * 180 + 10, y: -20, type: Math.random() > 0.5 ? 1 : 0}); } } for(let i=0; i<shooter.items.length; i++) { let item = shooter.items[i]; item.y += 2; if(item.y > 420) shooter.items.splice(i, 1); else if(Math.abs(item.x - shooter.playerX) < 15 && Math.abs(item.y - shooter.playerY) < 15) { shooter.items.splice(i, 1); i--; addScore(50); playSound('powerup'); } } for (let i = shooter.enemies.length - 1; i >= 0; i--) { let e = shooter.enemies[i]; e.y += 2; if(e.type === 1) e.x += Math.sin(e.y * 0.05) * 2; if (e.y > 420) { shooter.enemies.splice(i, 1); } if (Math.abs(e.x - shooter.playerX) < 15 && Math.abs(e.y - shooter.playerY) < 15) { triggerCrash(shooter.playerX, shooter.playerY, 23); } for (let j = shooter.bullets.length - 1; j >= 0; j--) { let b = shooter.bullets[j]; if (b && Math.abs(e.x - b.x) < 15 && Math.abs(e.y - b.y) < 15) { spawnExplosion(e.x, e.y, 25); playSound('brick'); addScore(50); shooter.enemies.splice(i, 1); shooter.bullets.splice(j, 1); i--; break; } } } }
    function drawShooter() { ctx.fillStyle = "#000"; ctx.fillRect(0, 0, 200, 400); ctx.fillStyle = "#FFF"; shooter.stars.forEach(s => ctx.fillRect(s.x, s.y, s.speed/2, s.speed/2)); ctx.fillStyle = COLORS[30]; shooter.items.forEach(it => ctx.fillRect(it.x-3, it.y-3, 6, 6)); ctx.fillStyle = COLORS[24]; shooter.bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 5, 4, 10)); shooter.enemies.forEach(e => { let c = e.type === 0 ? COLORS[25] : COLORS[26]; drawShip(e.x, e.y, c, true); }); drawShip(shooter.playerX, shooter.playerY, COLORS[23], false); }
    function drawShip(x, y, color, inverted) { ctx.fillStyle = color; let dir = inverted ? -1 : 1; ctx.beginPath(); ctx.moveTo(x, y - 10*dir); ctx.lineTo(x - 10, y + 10*dir); ctx.lineTo(x, y + 5*dir); ctx.lineTo(x + 10, y + 10*dir); ctx.closePath(); ctx.fill(); }

    /* --- LOOP --- */
    function switchGame() {
        if (!isSystemStarted) return;
        const modes = ['tetris', 'snake', 'race', 'breakout', 'pacman', 'frogger', 'grandprix', 'shooter'];
        gameMode = modes[(modes.indexOf(gameMode) + 1) % modes.length];
        titleEl.innerText = gameMode.toUpperCase();
        loadHighScore();
        resetGame();
    }
    function resetGame() {
        if(crashTimeout) clearTimeout(crashTimeout);
        gameoverScreen.style.display = 'none'; levelIndEl.style.opacity = 0;
        isGameOver = false; isCrashing = false; isPaused = false; score = 0; scoreEl.innerText = "0000"; particles = [];
        grid = createMatrix(COLS, ROWS);
        updateControlsLayout();
        
        if (gameMode === 'tetris') initTetris();
        else if (gameMode === 'snake') initSnake();
        else if (gameMode === 'race') initRace();
        else if (gameMode === 'breakout') initBreakout();
        else if (gameMode === 'pacman') initPacman();
        else if (gameMode === 'frogger') initFrogger();
        else if (gameMode === 'grandprix') initGrandPrix();
        else if (gameMode === 'shooter') initShooter();
    }
    function togglePause() { if (isGameOver || isCrashing || !isSystemStarted) return; isPaused = !isPaused; document.getElementById('btn-pause').classList.toggle('btn-active'); }
    function toggleSound() { soundEnabled = !soundEnabled; const btn = document.getElementById('btn-sound'); btn.classList.toggle('btn-active'); btn.style.color = soundEnabled ? '#fff' : '#888'; }
    
    function update(time = 0) {
        const dt = time - lastTime; lastTime = time;
        if (isSystemStarted) {
            processInputs(); // USANDO O NOVO PROCESSO COM DATE.NOW
            
            let isTurboTime = false;
            if(gameMode === 'snake' || gameMode === 'pacman' || gameMode === 'frogger') {
                if(inputState.up || inputState.down || inputState.left || inputState.right) isTurboTime = true;
            }
            let simDt = isTurboTime ? dt * 2.5 : dt; 

            try {
                if(gameMode !== 'grandprix' && gameMode !== 'shooter') ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!isPaused && !isGameOver && !isCrashing) {
                    if (gameMode === 'tetris') updateTetris(dt); 
                    else if (gameMode === 'snake') updateSnake(simDt);
                    else if (gameMode === 'race') updateRace(dt);
                    else if (gameMode === 'breakout') updateBreakout(dt);
                    else if (gameMode === 'pacman') updatePacman(simDt);
                    else if (gameMode === 'frogger') updateFrogger(dt);
                    else if (gameMode === 'grandprix') updateGrandPrix(dt);
                    else if (gameMode === 'shooter') updateShooter(dt);
                }
                if (gameMode === 'tetris') drawTetris();
                else if (gameMode === 'snake') drawSnake();
                else if (gameMode === 'race') drawRace();
                else if (gameMode === 'breakout') drawBreakout();
                else if (gameMode === 'pacman') drawPacman();
                else if (gameMode === 'frogger') drawFrogger();
                else if (gameMode === 'grandprix') drawGrandPrix();
                else if (gameMode === 'shooter') drawShooter();
                updateParticles(); drawParticles();
            } catch(e) { console.log("Recovered"); resetGame(); }
        }
        requestAnimationFrame(update);
    }
    update();
</script>
</body>
</html>
